#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <filesystem> // Required for filesystem operations in C++17 and above

#include "antlr4-runtime.h"
#include "generated/ifccLexer.h"
#include "generated/ifccParser.h"
#include "generated/ifccBaseVisitor.h"

#include "visitor/IRVisitor.h"
#include "visitor/CodeCheckVisitor.h"

namespace fs = std::filesystem; // Alias for filesystem

using namespace antlr4;
using namespace std;

int main(int argn, const char **argv)
{
    stringstream in;
    bool generate_cfg = false;

    // Check if the correct number of arguments are passed and parse arguments
    if (argn < 2)
    {
        cerr << "usage: ifcc path/to/file.c [--generate-cfg]" << endl;
        exit(1);
    }

    // Parse arguments to check for --generate-cfg flag
    for (int i = 2; i < argn; ++i)
    {
        if (strcmp(argv[i], "--generate-cfg") == 0)
        {
            generate_cfg = true; // Set flag to generate CFG
        }
    }

    // Open the file
    ifstream lecture(argv[1]);
    if (!lecture.good())
    {
        cerr << "error: cannot read file: " << argv[1] << endl;
        exit(1); // Exit with an error code
    }
    in << lecture.rdbuf(); // Read file content into the stringstream

    // Set up the ANTLR input stream
    ANTLRInputStream input(in.str());

    ifccLexer lexer(&input);
    CommonTokenStream tokens(&lexer);

    tokens.fill(); // Fill the token stream

    ifccParser parser(&tokens);
    tree::ParseTree *tree = parser.axiom(); // Parse the input file

    // Check for parsing errors
    if (parser.getNumberOfSyntaxErrors() != 0)
    {
        cerr << "error: syntax error during parsing" << endl;
        exit(1);
    }

    // Check code using visitor pattern
    CodeCheckVisitor sv;
    sv.visit(tree);

    // Generate Intermediate Representation (IR)
    IRVisitor v(sv.getCFGS());
    v.visit(tree); // Perform the IR transformation

    // Generate assembly code
    v.gen_asm(cout);

    if (generate_cfg)
    {
        // Get the CFGs generated by IRVisitor
        map<string, CFG *> cfgs = v.getCFGS();

        // Create a directory for the CFG files
        string file_path = argv[1];                          // Full path to the file
        fs::path path(file_path);                            // Create a filesystem path from the file path
        string folder_name = "cfgs/" + path.stem().string(); // Extract the file name without extension and path

        try
        {
            fs::create_directory("cfgs");
            fs::create_directory(folder_name + "_cfgs");
        }
        catch (const fs::filesystem_error &e)
        {
            cerr << "Error creating directory: " << e.what() << endl;
            return 1;
        }

        // Iterate over the CFGs and generate Graphviz dot files and PNG images
        for (auto it = cfgs.begin(); it != cfgs.end(); ++it)
        {
            string label = it->first;
            CFG *cfg = it->second;

            // Generate Graphviz .dot file
            ofstream dotFile(folder_name + "_cfgs/cfg_" + label + ".dot");
            cfg->gen_cfg_graphviz(dotFile);
            dotFile.close(); // Close the .dot file after writing

            // Generate PNG image from the .dot file using Graphviz
            string command = "dot -Tpng " + folder_name + "_cfgs/cfg_" + label + ".dot -o " + folder_name + "_cfgs/cfg_" + label + ".png";
            system(command.c_str()); // Execute the system command to generate the PNG
        }
    }

    return 0;
}
