# Project Overview

This document provides a technical and organizational overview of the project. You’ll find essential information to:

- Understand the project’s architecture and structure.
- Set up and run the project on different operating systems.
- Discover the testing strategy used to ensure code quality.
- Grasp project management and task distribution within the team.

This guide is designed as a clear and concise reference to help onboard new contributors and streamline collaboration within the team.

## Project Architecture

We chose to organize our project as follows:

Inside the `./compiler` directory at the root of the project, you’ll find the application’s source code.  
This directory contains:

- `Makefile`: used to compile our application.
- `config.mk`: configuration file for running ANTLR4.
- `ifcc.g4`: our ANTLR4 grammar file.
- The `generated` and `build` directories, which contain files generated by ANTLR4 and object files generated by the Makefile. These folders are created during the compilation process.

Our tests are implemented in the `./test/testfiles` directory.  
We’ve currently organized our tests into several subdirectories:

- `arithmetic`: tests for arithmetic operations.
- `assignment`: tests for variable assignments.
- `comparison`: tests for comparisons.
- `declaration`: tests for variable declarations.
- `block`: tests for code blocks, such as conditional blocks (`if`, `else`) and loops (`while`, `for`).
- `function`: tests for function definitions and calls.
  - In some cases, we use `getChar`, so you’ll need to press **Ctrl+D** to indicate the end of file.
- `incrementation`: tests for increment and decrement operations.
- `propagation_constant`: tests related to compiler optimization. These tests might be similar to others in different categories, but this folder lets us manually verify the generated assembly code for optimization validation.

Also, in the same `./test` folder, you’ll find the `ifcc-test.py` script, which allows you to run all tests with a single command:  
`python3 ifcc-test.py ./testfiles` to run all tests, or `python3 ifcc-test.py ./testfiles/<directory>` to run tests from a specific directory.

## Testing Strategy

### Naming Conventions

Our tests follow a clear naming convention:

- **Standard tests**: `<test_number>_<category_name>_<test_name>.c`
- **Error tests**: `<test_number>_<category_name>_<test_name>_FAILTEST.c`
- **Unimplemented feature tests**: `<test_number>_<category_name>_<test_name>_NOT_IMPLEMENTED.c`
- **Tests with undefined GCC behavior (randomly PASS or FAIL)**: `<test_number>_<category_name>_<test_name>_UNKNOWN.c`

### Test Logic

Our testing system is based on the following logic:

- **Standard tests**: Must compile and run correctly. The same applies to UNKNOWN tests.
- **FAILTEST tests**: Designed to fail intentionally.
  - A failure is considered a success (expected behavior).
  - An unexpected pass is considered a failure (since it means our compiler accepted invalid code).

### Preventing Regressions

To ensure code stability:

- All tests must pass before merging any changes into the main branch.
- The full test suite must be run for each new feature.

### Tests for Future Features

Tests for features not yet implemented are:

- Clearly identified by the `_NOT_IMPLEMENTED` suffix.
- Included in the final test statistics.
- Kept to document upcoming features for future development.

## Running the Project

### Instructions for macOS

If you’re using macOS on a machine with an ARM architecture (like Apple Silicon chips), you’ll need to use the **Rosetta emulator** to run the code in x86_64 mode. This is because our project isn’t natively compatible with ARM by default.

To enable Rosetta, follow these steps:

1. Open a terminal.
2. Start a bash session in x86_64 mode with the following command:

```bash
arch -x86_64 bash
```

**Note:** If you’ve previously run `make` under `arm64`, be sure to run `make clean` before recompiling in `i386` mode.

3. Once in this session, you can compile and run the project normally using the `Makefile`.

### Checking Your Terminal Architecture

To check the architecture your terminal is currently using, run:

```bash
uname -m
```

- If it returns `arm64`, you’re in ARM mode.
- If it returns `x86_64`, you’re in x86_64 mode.

### Common Issues & Troubleshooting

- **Compilation errors related to architecture**: Make sure you’ve launched the terminal in x86_64 mode before compiling.
- **Rosetta not installed**: If you haven’t installed Rosetta yet, macOS will prompt you to do so the first time you attempt to run an x86_64 application. Just follow the on-screen instructions.

### Future Compatibility

We had planned (if we’d had more time) to add native support for the ARM architecture in a future version of the project. This would allow the code to run directly on Apple Silicon machines without requiring Rosetta.

### For Other Operating Systems

- **Linux**: No special configuration needed. Just make sure the required dependencies are installed (Python 3 and ANTLR4).
- **Windows**: Use a WSL (Windows Subsystem for Linux) environment or a terminal compatible with GNU tools to run the project.

### Useful Commands

- To compile the project:
  ```bash
  make
  ```
- To run the tests:
  ```bash
  python3 ifcc-test.py ./testfiles
  ```
- To clean generated files:
  ```bash
  make clean
  ```
